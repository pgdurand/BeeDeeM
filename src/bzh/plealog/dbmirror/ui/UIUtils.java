/* Copyright (C) 2007-2021 Patrick G. Durand
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  You may obtain a copy of the License at
 *
 *     https://www.gnu.org/licenses/agpl-3.0.txt
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 */
package bzh.plealog.dbmirror.ui;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Frame;
import java.awt.Insets;
import java.io.File;
import java.text.NumberFormat;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;

import javax.swing.JComponent;
import javax.swing.JOptionPane;
import javax.swing.text.NumberFormatter;

import org.apache.commons.lang.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import bzh.plealog.dbmirror.ui.resources.DBMSMessages;
import bzh.plealog.dbmirror.util.conf.DBMSAbstractConfig;
import bzh.plealog.dbmirror.util.conf.DBMSConfigurator;
import bzh.plealog.dbmirror.util.descriptor.DescriptorEntry;

/**
 * Utility methods for the UI.
 * 
 * @author Patrick G. Durand
 */
public class UIUtils {
  private static final Logger       LOGGER   = LogManager.getLogger(DBMSAbstractConfig.KDMS_ROOTLOG_CATEGORY
                                                  + ".UIUtils");

  private static final String    CLIPPING = "...";

  private static NumberFormatter _intNumberFormmatter;

  public static NumberFormatter getIntNumberFormatter() {
    if (_intNumberFormmatter == null) {
      // override stringToValue and valueToString to allow empty strings
      _intNumberFormmatter = new NumberFormatter(NumberFormat.getInstance()) {

        private static final long serialVersionUID = 1L;

        @Override
        public Object stringToValue(String text) throws ParseException {
          return StringUtils.isBlank(text) ? null : super.stringToValue(text);
        }

        @Override
        public String valueToString(Object value) throws ParseException {
          return ((value == null) || (StringUtils.isBlank(value.toString()))) ? ""
              : super.valueToString(value);
        }
      };
      _intNumberFormmatter.setValueClass(Integer.class);
      _intNumberFormmatter.setMinimum(-1);
      _intNumberFormmatter.setMaximum(Integer.MAX_VALUE);
      _intNumberFormmatter.setAllowsInvalid(true);
      _intNumberFormmatter.setOverwriteMode(true);
    }
    return _intNumberFormmatter;
  }

  /**
   * Check the content of directory denoted by parameter path to locate and load
   * all DBServerConfig available. Return an empty list if nothing found. Please
   * note that this method looks for files having the extension dsc.
   */
  public static List<DescriptorEntry> getDescriptors(String path) {
    ArrayList<DescriptorEntry> entries;
    File fPath;
    File[] files;
    String fName;

    entries = new ArrayList<DescriptorEntry>();

    fPath = new File(path);
    if (fPath.isDirectory() == false)
      return entries;
    files = fPath.listFiles();
    for (File f : files) {
      if (f.isDirectory())
        continue;
      fName = f.getName();
      if (fName.endsWith(".dsc") == false)
        continue;
      // added for security issue : those files are generated by tghe Local DB
      // Installer
      // so remove them
      if (fName.startsWith(DBMSAbstractConfig.FPREF_DD)) {
        try {
          f.delete();
        } catch (Exception ex) {
        }
        continue;
      }
      try {
        entries.add(DescriptorEntry.createFrom(f));
      } catch (Exception ex) {
        LOGGER.warn("unable to read descriptor: " + f.getAbsolutePath() + ": "
            + ex);
      }
    }
    return entries;
  }

  /**
   * Clip a text.
   * 
   * @param c
   *          the component used to clip the text. Width and FontMetrics from
   *          that component will be used for that purpose.
   * @param val
   *          the text to clip.
   * @param borderWidth
   *          width of the component border if any.
   * 
   * @return a clipped text terminating with three dots if the text does not fit
   *         within the component. Otherwise, the text remains unchanged.
   */
  public static String clipText(JComponent c, String val, int borderWidth) {
    FontMetrics fm;
    String str;
    Insets insets;
    int i, size, width, totWidth;

    fm = c.getFontMetrics(c.getFont());
    insets = c.getInsets();
    width = c.getWidth() - (insets.left + insets.right) - 2 * borderWidth;
    totWidth = fm.stringWidth(CLIPPING) + 2 * borderWidth;
    size = val.length();
    for (i = 0; i < size; i++) {
      totWidth += fm.charWidth(val.charAt(i));
      if (totWidth > width) {
        break;
      }
    }
    if (i < size) {
      str = val.substring(0, i) + CLIPPING;
    } else {
      str = val;
    }
    return str;
  }

  /**
   * Clip a text.
   * 
   * @param fm
   *          the FontMetrics used to compute the clipped text.
   * @param val
   *          the text to clip.
   * @param width
   *          width of the component where the string will be displayed.
   * 
   * @return a clipped text terminating with three dots if the text does not fit
   *         within the component. Otherwise, the text remains unchanged.
   */
  public static String clipText(FontMetrics fm, String val, int width) {
    String str;
    int i, size, totWidth;

    totWidth = fm.stringWidth(CLIPPING);
    size = val.length();
    for (i = 0; i < size; i++) {
      totWidth += fm.charWidth(val.charAt(i));
      if (totWidth > width) {
        break;
      }
    }
    if (i < size) {
      str = val.substring(0, i) + CLIPPING;
    } else {
      str = val;
    }
    return str;
  }

  /**
   * Clip a text.
   * 
   * @param c
   *          the component used to clip the text. Width from that component
   *          will be used for that purpose.
   * @param fnt
   *          the Font to use to evaluate whether or not the text fits within
   *          the component. If null, Font is retrieved from the component.
   * @param val
   *          the text to clip.
   * @param xFrom
   *          starting x position within the component
   * @param xTo
   *          ending position within the component
   * 
   * @return a clipped text terminating with three dots if the text does not fit
   *         within xFrom and xTo. Otherwise, the text remains unchanged.
   */
  public static String clipText(JComponent c, Font fnt, String val, int xFrom,
      int xTo) {
    FontMetrics fm;
    String str;
    int i, size, totWidth;

    fm = c.getFontMetrics(fnt != null ? fnt : c.getFont());
    totWidth = xFrom;
    size = val.length();
    for (i = 0; i < size; i++) {
      totWidth += fm.charWidth(val.charAt(i));
      if (totWidth > xTo) {
        break;
      }
    }
    if (i < size) {
      str = val.substring(0, i) + CLIPPING;
    } else {
      str = val;
    }
    return str;
  }

  /**
   * Centers the component on the screen.
   */
  public static void centerOnScreen(Component compo) {
    Dimension screenSize = compo.getToolkit().getScreenSize();
    Dimension dlgSize = compo.getSize();

    compo.setLocation(screenSize.width / 2 - dlgSize.width / 2,
        screenSize.height / 2 - dlgSize.height / 2);
  }

  public static boolean askForMirrorPath(Frame parent) {
    // first time: check we have a mirror repository to use
    ChooseMirrorConfigDlg configDlg;
    String mirrorPath = DBMSAbstractConfig.getConfigurator().getProperty(
        DBMSConfigurator.MIRROR_PATH);
    if (mirrorPath == null || mirrorPath.length() == 0
        || mirrorPath.startsWith("@BIOBASE_ROOTDIR@")) {
      JOptionPane.showMessageDialog(parent,
          DBMSMessages.getString("ChooseMirrorConfigDlg.intro"),
          DBMSMessages.getString("ChooseMirrorConfigDlg.header"),
          JOptionPane.INFORMATION_MESSAGE | JOptionPane.OK_OPTION);
      configDlg = new ChooseMirrorConfigDlg(parent);
      configDlg.showDlg();
      return (configDlg.isOk());
    }
    return true;
  }

  /**
   * Check if string txt is only made of letters, digit, minus char or
   * underscore char. All other chars are replaced with a minus char.
   */
  public static String cleanName(String txt) {
    if (txt == null)
      return txt;
    StringBuffer buf;
    char ch;
    int i, size;

    buf = new StringBuffer();
    size = txt.length();
    for (i = 0; i < size; i++) {
      ch = txt.charAt(i);
      if (!(Character.isLetterOrDigit(ch) || ch == '_' || ch == '-')) {
        ch = '_';
      }
      buf.append(ch);
    }
    return buf.toString();
  }
}
